import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Button, Input, Card, Space, Divider, Typography, Tooltip } from 'antd';
import { PlusOutlined, DeleteOutlined, EditOutlined, EyeOutlined, CopyOutlined, ArrowUpOutlined, ArrowDownOutlined } from '@ant-design/icons';
import TemplateDataSelector from './TemplateDataSelector';

const { TextArea } = Input;
const { Title, Text } = Typography;

export default function OutputConfigurator({ 
  outputConfig, 
  setOutputConfig, 
  onAutoGeneratedPromptCreated,
  selectedTemplate,
  fileNotesFull,
  kpi2Calculators
}) {

  // Initialize sections with proper dataRequirements format
  const initializeSections = useCallback((configSections) => {
    if (!configSections || configSections.length === 0) return [];
    
    return configSections.map(section => {
      if (typeof section.dataRequirements === 'string') {
        return {
          ...section,
          dataRequirements: {
            kpiSelected: [],
            tableSelected: []
          }
        };
      }
      return section;
    });
  }, []);
  
  const [sections, setSections] = useState(() => initializeSections(outputConfig?.sections));
  
  // Memoize the normalized sections to prevent unnecessary re-renders
  const normalizedSections = useMemo(() => {
    const newSections = outputConfig?.sections || [];
    return newSections.map(section => {
      if (typeof section.dataRequirements === 'string') {
        return {
          ...section,
          dataRequirements: {
            kpiSelected: [],
            tableSelected: []
          }
        };
      }
      return section;
    });
  }, [outputConfig?.sections]);

  // Generate auto prompt from sections - memoized to prevent unnecessary recalculations
  const generatePromptFromSections = useCallback((sections) => {
    if (sections.length === 0) return '';

    let prompt = 'Hãy phân tích và trả lời theo cấu trúc sau:\n\n';
    
    sections.forEach((section, index) => {
      const sectionLetter = String.fromCharCode(97 + index); // a, b, c, ...
      prompt += `${sectionLetter}) ${section.title || `Phần ${sectionLetter.toUpperCase()}`}:\n`;
      
      if (section.content) {
        prompt += `   - Nội dung: ${section.content}\n`;
      }
      
      // Include dataRequirements info for JSON structure
      if (section.dataRequirements && typeof section.dataRequirements === 'object') {
        const kpiIds = section.dataRequirements.kpiSelected || [];
        const tableIds = section.dataRequirements.tableSelected || [];
        
        if (kpiIds.length > 0 || tableIds.length > 0) {
          prompt += `   - Dữ liệu sử dụng: `;
          const dataInfo = [];
          
          if (kpiIds.length > 0) {
            dataInfo.push(`KPI: ${kpiIds.join(', ')}`);
          }
          if (tableIds.length > 0) {
            dataInfo.push(`Bảng: ${tableIds.join(', ')}`);
          }
          
          prompt += dataInfo.join(', ') + '\n';
        }
      }
      
      prompt += '\n';
    });

    prompt += 'Vui lòng trả lời theo đúng cấu trúc trên, mỗi phần phải rõ ràng và đầy đủ thông tin. Chỉ trả về nội dung câu trả lời, không giải thích gì thêm, bỏ qua lời dẫn ban đầu.';
    
    return prompt;
  }, []);

  // Auto-generate prompt whenever sections change
  const generatedPrompt = useMemo(() => {
    const prompt = generatePromptFromSections(sections);
    // Notify parent about the new prompt
    onAutoGeneratedPromptCreated?.(prompt);
    return prompt;
  }, [sections, generatePromptFromSections, onAutoGeneratedPromptCreated]);

  // Update parent when sections change
  useEffect(() => {
    const newConfig = {
      sections: sections,
      generatedPrompt: generatedPrompt,
      autoGeneratedPrompt: generatedPrompt
    };
    
    setOutputConfig(newConfig);
  }, [sections, generatedPrompt, setOutputConfig]);

  // Sync with parent config changes
  useEffect(() => {
    if (JSON.stringify(sections) !== JSON.stringify(normalizedSections)) {
      setSections(normalizedSections);
    }
  }, [normalizedSections]);

  const addSection = useCallback(() => {
    setSections(prev => {
      const newSection = {
        id: Date.now(),
        title: '',
        content: '',
        dataRequirements: {
          kpiSelected: [],
          tableSelected: []
        },
        order: prev.length + 1
      };
      return [...prev, newSection];
    });
  }, []);

  const removeSection = useCallback((id) => {
    setSections(prev => prev.filter(section => section.id !== id));
  }, []);

  const updateSection = useCallback((id, field, value) => {
    setSections(prev => prev.map(section => {
      if (section.id === id) {
        if (field === 'dataRequirements') {
          // Handle dataRequirements as object
          const newDataRequirements = {
            ...section.dataRequirements,
            ...value
          };
          
          return { 
            ...section, 
            dataRequirements: newDataRequirements
          };
        }
        
        return { ...section, [field]: value };
      }
      return section;
    }));
  }, []);

  const moveSection = useCallback((id, direction) => {
    setSections(prev => {
      const currentIndex = prev.findIndex(section => section.id === id);
      if (currentIndex === -1) return prev;

      const newSections = [...prev];
      if (direction === 'up' && currentIndex > 0) {
        [newSections[currentIndex], newSections[currentIndex - 1]] = 
        [newSections[currentIndex - 1], newSections[currentIndex]];
      } else if (direction === 'down' && currentIndex < prev.length - 1) {
        [newSections[currentIndex], newSections[currentIndex + 1]] = 
        [newSections[currentIndex + 1], newSections[currentIndex]];
      }
      return newSections;
    });
  }, []);

  const duplicateSection = useCallback((id) => {
    setSections(prev => {
      const sectionToDuplicate = prev.find(section => section.id === id);
      if (!sectionToDuplicate) return prev;

      const newSection = {
        ...sectionToDuplicate,
        id: Date.now(),
        title: `${sectionToDuplicate.title} (Bản sao)`,
        order: prev.length + 1
      };
      return [...prev, newSection];
    });
  }, []);

  const getSectionLetter = useCallback((index) => {
    return String.fromCharCode(97 + index); // a, b, c, ...
  }, []);

  return (
    <div style={{ marginTop: '16px', border: '1px solid #d9d9d9', borderRadius: '8px', padding: '16px' }}>
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center', 
        marginBottom: '16px' 
      }}>
        <Title level={5} style={{ margin: 0 }}>
          Cấu hình cấu trúc đầu ra
        </Title>
        <Button 
          type="primary" 
          icon={<PlusOutlined />} 
          onClick={addSection}
          size="small"
        >
          Thêm phần
        </Button>
      </div>

      {sections.length === 0 && (
        <div style={{
          textAlign: 'center',
          padding: '32px',
          border: '2px dashed #d9d9d9',
          borderRadius: '8px',
          backgroundColor: '#fafafa'
        }}>
          <Text type="secondary">
            Chưa có phần cấu trúc nào. Nhấn "Thêm phần" để bắt đầu cấu hình.
          </Text>
          <div style={{ marginTop: '8px', fontSize: '12px', color: '#999' }}>
            Sections count: {sections.length}
          </div>
        </div>
      )}

      {sections.map((section, index) => {
        return (
          <Card
            key={section.id}
            size="small"
            style={{ marginBottom: '12px' }}
          title={
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <span style={{ 
                fontWeight: 'bold', 
                color: '#1890ff',
                fontSize: '16px'
              }}>
                {getSectionLetter(index)}
              </span>
              <Input
                placeholder="Tên phần (ví dụ: Tổng quan, Phân tích chi tiết, Kết luận)"
                value={section.title}
                onChange={(e) => updateSection(section.id, 'title', e.target.value)}
                style={{ flex: 1 }}
                size="small"
                onBlur={(e) => {
                  // Ensure the value is updated on blur
                  if (e.target.value !== section.title) {
                    updateSection(section.id, 'title', e.target.value);
                  }
                }}
              />
            </div>
          }
          extra={
            <Space size="small">
              <Tooltip title="Di chuyển lên">
                <Button
                  size="small"
                  icon={<ArrowUpOutlined />}
                  onClick={() => moveSection(section.id, 'up')}
                  disabled={index === 0}
                />
              </Tooltip>
              <Tooltip title="Di chuyển xuống">
                <Button
                  size="small"
                  icon={<ArrowDownOutlined />}
                  onClick={() => moveSection(section.id, 'down')}
                  disabled={index === sections.length - 1}
                />
              </Tooltip>
              <Tooltip title="Sao chép phần">
                <Button
                  size="small"
                  icon={<CopyOutlined />}
                  onClick={() => duplicateSection(section.id)}
                />
              </Tooltip>
              <Tooltip title="Xóa phần">
                <Button
                  size="small"
                  danger
                  icon={<DeleteOutlined />}
                  onClick={() => removeSection(section.id)}
                />
              </Tooltip>
            </Space>
          }
        >
          <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
            <div>
              <Text strong style={{ fontSize: '12px', color: '#666' }}>
                Mô tả nội dung:
              </Text>
              <TextArea
                placeholder="Mô tả chi tiết nội dung cần có trong phần này (ví dụ: Phân tích xu hướng, so sánh với kỳ trước, đưa ra nhận xét...)"
                value={section.content}
                onChange={(e) => updateSection(section.id, 'content', e.target.value)}
                rows={2}
                size="small"
                onBlur={(e) => {
                  // Ensure the value is updated on blur
                  if (e.target.value !== section.content) {
                    updateSection(section.id, 'content', e.target.value);
                  }
                }}
              />
            </div>
            
            <div>
              <Text strong style={{ fontSize: '12px', color: '#666' }}>
                Dữ liệu sử dụng (từ template):
              </Text>
              <TemplateDataSelector
                section={section}
                updateSection={updateSection}
                templateData={selectedTemplate?.data_selected || []}
                templateKpis={selectedTemplate?.kpiSelected || []}
                fileNotesFull={fileNotesFull || []}
                kpi2Calculators={kpi2Calculators || []}
              />
            </div>
          </div>
        </Card>
        );
      })}

      {sections.length > 0 && (
        <>
          <Divider />
          <div>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              alignItems: 'center',
              marginBottom: '8px'
            }}>
            
              {/* <Tooltip title="Prompt được tạo tự động từ cấu hình cấu trúc đầu ra">
                <Button
                  size="small"
                  icon={<EyeOutlined />}
                  onClick={() => {
                    console.log('Generated Prompt:', generatedPrompt);
                  }}
                >
                  Xem prompt
                </Button>
              </Tooltip> */}
            </div>
            <TextArea
              value={generatedPrompt}
              readOnly
              rows={8}
              style={{ 
                backgroundColor: '#f8f9fa',
                fontFamily: 'monospace',
                fontSize: '12px',
                border: '1px solid #e9ecef',
                borderRadius: '6px'
              }}
              placeholder="Prompt sẽ được tự động tạo từ cấu hình các phần..."
            />
            <div style={{ 
              marginTop: '8px', 
              fontSize: '11px', 
              color: '#6c757d',
              fontStyle: 'italic'
            }}>
              💡 Prompt này sẽ tự động thay đổi khi bạn chỉnh sửa tên phần, nội dung hoặc dữ liệu sử dụng
            </div>
          </div>
        </>
      )}
    </div>
  );
}
